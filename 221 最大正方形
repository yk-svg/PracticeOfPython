### 221最大正方形
#### 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。
#### 输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]] 输出：4
##### 解题思路：还是使用动态规划，一开始其实没有思路，只是模糊感觉要抓住大正方形与小正方形的关系，但发现错了，或者说不合适，因为容易重叠，正方形有四个角，所以容易重复，如果为了这个开数组，会浪费，所以看了题解，题解思路是
我固定一个角，譬如右下角，正方形的右下角，然后找递推公式，设置的dp[i][j]代表以(i,j)为右下角的正方形的最大边长，一开始理解不了递推公式：dp(i,j)=min(dp[i-1][j],dp[i-1][j-1],dp[i][j-1])+1，递推公式，后面直接上实例[[1,1,1,1,0],
[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1],[1,1,1,1,1]]，举dp[4][4]的例子的时候发现了问题，dp[4][4]=4，但dp[3][3]=4，根本原因在于在包含原有边长-1的情况之下，原有边长之外有可能存在使得左上角或者其他角构成一个大边长的正方形的情况，
倒过来思考也是如此，由此理解公式。当然要考虑边界值，还有矩阵数值为零的情况。
```
class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();
        int max = 0;
        vector<vector<int>> dp(m, vector<int>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '0') {
                    dp[i][j] = 0;
                } else if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                        if (max < dp[i][j])
                            max = dp[i][j];
                    } else {
                        dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]),
                                       dp[i - 1][j - 1]) +
                                   1;
                        if (max < dp[i][j]) {
                            max = dp[i][j];
                        }
                    }
                }
            }
        }
        int square;
        square = max * max;
        return square;
    }
};
```
