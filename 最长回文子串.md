## 最近学算法,有一个感悟是好像考虑太多鸡毛蒜皮的事情,在做算法题目的时候容易被题目表面的一些状态叠加所迷惑,可是好的解法往往简洁明了,生活也是如此.
## 题目：最长回文子串
### 题目要求：给你一个字符串 s，找到 s 中最长的回文子串.
### 示例 1：输入：s = "babad"，输出："bab"，解释："aba" 同样是符合题意的答案.
### 示例 2：输入：s = "cbbd"，输出："bb"
#### 解题思路：一开始没有想明白,还是从最简单的开始,一个字母,两个字母,边界条件是这个没错,但转移方程要考虑题目自身的条件,回文字符串代表最开始字母与结尾字母相同,去除这两个字母得到的新的回文字符串仍然遵守这个规律,这样才找到转移方程,也就是当(i,j)代表从i位置到j位置的字符串,去除i,j这两个位置的字符得到的(i+1,j-1)的字符串仍然是回文字符串,这样才解决了问题,没有找准规律,是求解这个题目的最大问题.
```
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        int start = 0, end = 0;
        for (int i = 0; i < n; i++) { // 很漂亮的代码
            int l = i, r = i;
            while (l >= 0 && r < n && s[l] == s[r])
                l--, r++; // 判断偶数串的情况，以中心往外扩张
            l++, r--; // 跳出循环的时候，就是不满足条件的时候，所以回复前一状态
            if (r - l > end - start)
                start = l, end = r; // 判断是否是最长字符串
            l = i, r = i + 1;       // 判断偶数串的情况
            while (l >= 0 && r < n && s[l] == s[r])
                l--, r++;
            l++, r--;
            if (r - l > end - start)
                start = l, end = r;
        }
        return s.substr(start, end - start + 1);
    }
};
```